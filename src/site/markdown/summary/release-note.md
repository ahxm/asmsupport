# Release Notes

## 0.4

### 新特性

1. 增加全新Dummy方式API
2. 采用链式结构作为执行队列
3. 重构程序块实现
4. 采用asm 0.5版本
5. 第三方jar包零依赖
6. 简化优化接口设计
7. 获取类或者变量的成员时判断是否有权限访问

### 已修复

1 . catch块中重复的异常名"e"

>创建一个Try...catch程序块，再在try中再创建一个try...catch块会抛出重复变量名e的异常. 

2 . 生成调用构造方法的字节码时，传递的参数列表和和实际参数列表不同，但仍能创建成功

>这个问题出在AbstractMethodChooser这个类，他搜索可用的构造方法的时候如果在当前类没有找到则会到父类中找，实际上这对于普通的方法检测是正确的，但是对于构造方法，我们只能在当前类搜索。已解决, 测试实例/src/issue/java/bug/fixed/test2054

3 . 生成变元方法的调用，并且传入空参数抛下标越界

>存在一个方法，该方法只有一个形参，并且该方法是个变元参数。当创建方法调用的时候，我们不像该方法传递任何参数，则会抛异常，数组下标越界异常，访问了下标为-1的元素. 已解决。

4 . AClass的isChildOrEqual方法异常(接口不是Object子类)

> 已解决

5 . 重写父类方法，但是设置其返回类型为被重写方法的返回类型的子类型

> 在Java 1.4中，子类若要重写父类某个方法，那么子类的方法和父类的方法签名必须完全一致，包括方法名、参数类型以及返回值；而到Java 1.5中，该机制变成，如果子类中某个方法的方法名和参数类型和父类某方法一致，并且子类该方法的返回值是父类相应方法返回值的类型或其子类型，那么该子类方法也可以重写父类中相应的方法。通过BRIDGE字节码关键字修复，已解决 src/issue/java/test/test2463

6 . 新创建的方法中无法调用重写方法

> 假设存在如下类Super,Child,Test。Child是Super的子类；Test中存在一个方法test, 这个方法返回类型为Super。新建一个类TestSub，令其继承Test，并且重写Test中的test方法，并且令这个test方法返回类型为Child（方法描述如下：public Child test()）; 再在TestSub创建任意一个方法，并且在这个方法中调用之前重写test方法。 结果会出现异常。已解决 src/issue/java/bug/fixed/test30205

7 . 无法生成获取父类属性的字节码

> 1.存在类A，A中存在一个public static的属性a, 2.使用ASMSupport生成一个类B，继承A， 3.在B中创建任意方法，并且在该方法中获取A中的属性a。 抛空指针异常。 已解决 ： src/issue/java/bug/fixed/test65150

8 . 创建的枚举类型缺少常量ENUM$VALUES

9 . 创建的枚举类缺少values方法和valueOf方法

### 已知Issue

1. 无泛型支持
2. 无法创建内部类
3. 无法创建循环引用
4. 目前只支持生成最高1.6的jdk版本的class。因为目前asmsupport未支持"Stack map table"，而该属性在1.7后强制需要。
